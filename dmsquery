#!/usr/bin/perl

use strict;
use warnings;

use IO::Socket;
use Storable qw(nfreeze thaw);
use Term::ANSIColor;
use List::Util;

use constant {
  _SERVER  => 'deliveryweb.sonyericsson.net',
  _PORT    => 9098,
  _VERSION => 'P.1',
  _TPL     => '__UNDEF__', # change this to use a permanent Query Template
  _QUERY   => '__UNDEF__', # change this to use a permanent output file
  _UNDEF   => '__UNDEF__',
  _ON      => 1,
  _OFF     => 0,
  _USE_COLOR => 1,
};

#----------------------------------------------------------------
#  Send request to server
#----------------------------------------------------------------
sub server_request { 
  my($request, @aRequest) = @_;
  # setup connection
  my $oSocket = IO::Socket::INET->new( Proto    => 'tcp', 
                                       PeerAddr => _SERVER,
                                       PeerPort => _PORT,
                                       Timeout  => 5 ); 
  return(1, 'Unable to connect to Server') if (!$oSocket);
  
  unshift(@aRequest, $request, _VERSION);
  
  my $result = nfreeze(\@aRequest);
  # escape newlines, CR and %
  $result =~ s/([%\r\n])/sprintf("%%%02X", ord($1))/ge;
  $result .= "\n";

  eval {
    local $SIG{ALRM} = sub {die "TIMEOUT\n"}; # Note: \n required
    alarm(30);

    print $oSocket $result;
    $result = <$oSocket>;

    alarm(0);
  };
  if ($@ && $@ eq "TIMEOUT\n") {
    # timed out
    close $oSocket; 
    return(1, 'Server Timeout');
  }
  else {
    close $oSocket; 
    # reverse escaped newline, CR and %
    $result =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/ge;
    my @aResult = @{thaw($result)}; 
    return(@aResult);
  }
}

sub init_parser {
  my($ph, $p) = @_;
  $$ph{$p}{dms} = {} unless (exists $$ph{$p}{dms});
  $$ph{$p}{file} = {} unless (exists $$ph{$p}{file});
  $$ph{$p}{no_commit} = 1;

  foreach ('no_dms', 'commit') {
    $$ph{$p}{$_} = 0 unless (exists $$ph{$p}{$_});
  }
  foreach ('count', 'inserted', 'deleted', 'binary') {
    $$ph{$p}{file}{$_} = 0 unless (exists $$ph{$p}{file}{$_});
  }
}

#----------------------------------------------------------------
#  Parse Git log
#----------------------------------------------------------------
sub parse_git_log {
  my($data, $option, $result) = @_;
  my @Data = (ref $data ? @$data : ($data));
  return($result) unless (@Data);
  
  my $project = _UNDEF;
  init_parser($result, $project);
  my $list_project = ($$option{'show-p'} || $$option{'show-stat-p'});
  my $no_dms = 1;
  foreach (@Data) {
    if ($list_project && /^project\s(.+\/)$/o) {
      $$result{$project}{no_dms} += $no_dms unless ($$result{$project}{no_commit});
      $project = $1;
      $no_dms = 1;
      init_parser($result, $project);
    }
    elsif (/^commit/o) {
      $$result{$project}{no_dms} += $no_dms unless ($$result{$project}{no_commit});
      $$result{$project}{commit}++;
      $no_dms = 1;
      undef $$result{$project}{no_commit}; 
    }
    elsif (/^(\-|\d+)\s+(\-|\d+)\s+(.+)/o) { 
      if (!exists $$result{$project}{file}{$3}) {
        $$result{$project}{file}{$3} = 1;
        $$result{$project}{file}{count}++; 
        $$result{$project}{file}{binary}++ if ($1 eq '-') ; 
      }
      $$result{$project}{file}{inserted} += $1 unless ($1 eq '-'); 
      $$result{$project}{file}{deleted} += $2 unless ($2 eq '-'); 
    }
    elsif ($$option{slurp} && /DMS\d{8}/o) {
      $no_dms = 0; 
      foreach (/DMS\d{8}/g) {
        $$result{$project}{dms}{$_} = {} unless(exists $$result{$project}{dms}{$_}); 
      }
    }
    elsif (/^\s*[Ff][Ii][Xx]\=(DMS\d{8})/o) {
      my $issue = $1;
      $no_dms = 0; 
      $$result{$project}{dms}{$issue} = {}  unless(exists $$result{$project}{dms}{$1});
      $$result{$project}{dms}{$issue}{main} = $1 if (/^\s*[Ff][Ii][Xx]\=DMS\d{8}\sMAIN\=(DMS\d{8})/o);
      $$result{$project}{dms}{$issue}{title} = $1 if (/DMS\d{8}\s*(.+)/o);
    }
  } 
  # catch the last commit
  $$result{$project}{no_dms} += $no_dms unless ($$result{$project}{no_commit});

  return($result);
}

#----------------------------------------------------------------
#  Display help message
#----------------------------------------------------------------
sub help {
my($name) = $0 =~/.*\/(.*)$/;
  return <<END
\033[1m NAME\033[0m
\033[32m   $name\033[0m - Create a DMS Query for import to DMS(ClearQuest)

\033[1m SYNOPSIS\033[0m
\033[32m   $name\033[0m \033[33m--<option>\033[0m [\033[33m-<option>\033[0m <value>] [\033[33m-<option>\033[0m <value>]...

\033[1m DESCRIPTION\033[0m
    Parse indata for DMS Issues and create a DMS Query for import to DMS(ClearQuest)
    or display a list of DMS Issues.
           
    Display statistics over commits, DMS Issues and changes.
    (only in combination with the option --numstat in git-log)
    
    It is possible to setup a default Query template and output file.  

\033[1m OPTIONS\033[0m
\033[33m   --help\033[0m   : display this help
\033[33m   --main\033[0m   : use Main Issue if present(FIX=DMSnnnnnnnn MAIN=DMSnnnnnnnn)
\033[33m   --slurp\033[0m  : parse indata for all DMS Issues(default only FIX=DMSnnnnnnnn is parsed)
\033[33m   --show\033[0m   : only list the parsed result
\033[33m   --show-p\033[0m : list result by project
\033[33m   --show-t\033[0m : include the Issue title
\033[33m   --show-stat\033[0m   : list statistics of commits, dms Issues etc.
\033[33m   --show-stat-p\033[0m : list statistics per project

\033[33m   -qry\033[0m <filename>   : output file (.qry will be added if missing)
\033[33m   -tpl\033[0m <query file> : Query to use as template
\033[33m   -add\033[0m <string|filename> : string or file to parse for DMS Issues

\033[1m EXAMPLES\033[0m
\033[32m   $name\033[0m \033[33m-qry\033[0m  my_query \033[33m-add\033[0m  data.txt
\033[32m   $name\033[0m \033[33m-qry\033[0m  my_query \033[33m-add\033[0m  'DMS00000123, DMS00044126'

\033[1m PIPE EXAMPLES\033[0m
   git log | \033[32m$name\033[0m \033[33m--show\033[0m
   git log | \033[32m$name\033[0m \033[33m-tpl\033[0m my_template.qry >my_query.qry
   repo forall -cvp 'git log --no-merges HEAD..\$REPO_RREV' | \033[32m$name\033[0m \033[33m-qry\033[0m my_query
   repo forall -cvp 'git log --no-merges --numstat --since="2 weeks ago"' | \033[32m$name\033[0m \033[33m--show-stat-p\033[0m

   Note: When invoked from a script(e.g. Hudson) which has redirected STDOUT to a logfile,
   the binary query-file could end up in the logfile if no output file is defined.

\033[1m Multiple branches and SW Branch Issues\033[0m
\033[33m   --swb\033[0m : include all related SW Branch and Main Issues in the Query
\033[33m   --swb --show\033[0m : list all related  SW Branch and Main Issues.

\033[33m   -fix-for\033[0m <fix-for-tag> : DMS 'Fix for' tag, multiple -fix-for entries supported,
   '*' at the end of the tag is treated as a wildcard. Use 'NONE' to indicate that
   untagged Issues are accepted. \033[32m$name\033[0m will select the first related SW Branch
   or Main Issue with a matching tag. The tags are evaluated in the entered order. 

   To manually select the Issues to include in the Query:
   1. repo forall -cvp 'git log --no-merges HEAD..\$REPO_RREV' | \033[32m$name\033[0m \033[33m--swb --show\033[0m >dms.txt
   2. Edit the file dms.txt, remove all lines with undesired DMS Issues and save.
   3. \033[32m$name\033[0m \033[33m-add\033[0m dms.txt  
 
END

}

#----------------------------------------------------------------
#  Display error message
#----------------------------------------------------------------
sub print_error {
  my %E = (@_);
  my($name) = $0 =~/.*\/(.*)$/;
  
  if ($E{header}) {
    print STDERR color('red', 'bold') if (_USE_COLOR);
    print STDERR $E{header};
    print STDERR color('reset') if (_USE_COLOR);
    print STDERR $E{problem} if ($E{problem});
  }
  if ($E{message}) {
    print STDERR "\n";
    print STDERR $E{message};
  }
  if ($E{help}) {
    print STDERR "\n";
    print STDERR 'For help use:  ' . $name . ' --help';
  }
  print STDERR "\n";
}

sub print_marked {
  print color('blue', 'bold') if (-t STDOUT && _USE_COLOR);
  print '*';
  print color('reset') if (-t STDOUT && _USE_COLOR);
  return '';
}
sub print_problem {
  my($problem) = @_;
  return unless($problem);
  print color('red') if (-t STDOUT && _USE_COLOR);
  print '! ', $problem;
  print color('reset') if (-t STDOUT && _USE_COLOR);
}

#----------------------------------------------------------------
# -- Main --
#----------------------------------------------------------------
if (grep(/\-+help/, @ARGV)) {
  my $help = help();
  $help =~s/\033.+?m//g if (!_USE_COLOR || !-t STDOUT);
  print $help;
  exit;
}

my %Option = (
  tpl   => _TPL, 
  qry   => _QUERY,
  add   => _UNDEF, 
  'fix-for' => [], 
  slurp => _OFF,
  main  => _OFF,
  swb   => _OFF,
  help  => _OFF,
  show  => _OFF,
  'show-t' => _OFF,
  'show-p' => _OFF,
  'show-stat'   => _OFF,
  'show-stat-p' => _OFF,
);

# validate arguments
while (my $par = shift) {
  my $orig = $par; 
  $par =~s/^[\-]+//;

  if (exists $Option{$par}) {
    if ($Option{$par} eq _UNDEF) {
      $Option{$par} = shift;
    }
    elsif (ref $Option{$par} && ref $Option{$par} eq 'ARRAY') {
      push(@{$Option{$par}}, shift);
    }
    else {
      $Option{$par} = _ON;
      $Option{show} = _ON if ($par =~/^show\-/);
      $Option{'show-stat'} = _ON if ($par =~/^show\-stat\-/);
    }     
  }
  else {
    print_error( header  => 'Unknown option: ',
                 problem => $orig,
                 help    => 1 );
    exit; 
  }
}

my $qryTemplate;
if (!$Option{show}) {
  # output
  if ($Option{qry} eq _UNDEF) {
    if (-t STDOUT) {
      print_error( header => 'No output file defined',
                   help   => 1 );
      exit;
    }
  }
  else {
    $Option{qry} .= '.qry' unless ($Option{qry} =~/\.qry$/);   
  }
  
  # Query template
  if ($Option{tpl} ne _UNDEF) {
    if (open(my $fh, '<', $Option{tpl})) {
      binmode $fh;
      $qryTemplate = do{local($/); <$fh>};
      close($fh);
    }
    else {
      print_error( header  => 'Unable to open Query template: ',
                   problem => $Option{tpl} );
      exit;
    }
  }
}

# indata
my @inData = ();
@inData = <STDIN> if (!-t STDIN);

if ($Option{add} ne _UNDEF && open(my $fh, '<', $Option{add})) {
  push(@inData, (<$fh>));
  close($fh);
  $Option{add} = _UNDEF;
}


my %Parsed = ();
parse_git_log(\@inData, \%Option, \%Parsed);

if ($Option{add} ne _UNDEF){
  # Note: always slurp string input
  $Option{slurp} = _ON;
  parse_git_log($Option{add}, \%Option, \%Parsed);
}

if ($Option{swb} && scalar(keys %Parsed)) {
  # Use SW branch Issues
  my @Issue;
  foreach (keys %Parsed) {
    push(@Issue, (keys %{$Parsed{$_}{dms}}));
  }

  if (@Issue) {
    my %Issue = map({$_ => 1} @Issue);
    @Issue = sort keys %Issue;

    # get related Issues from DMS  
    my @Result = server_request('dms_swb', @Issue);
    if (shift @Result) {
      print_error( header  => 'Failed: ',
                   message => shift @Result );
    }
    else {
      foreach my $I (@Result) {
        if (@{$Option{'fix-for'}}) {
          next if ($$I{problem});
          # find the correct Issue to use
          $$I{fix_for} ||= 'UNDEF';
          foreach (@{$Option{'fix-for'}}) {
            my $regex = '^';
            if (/\*$/) {
              my $fix = $_;
              chop($fix);
              $regex .= quotemeta($fix);
            }
            else {
              $regex .= quotemeta($_) . '$';
            }
            
            if ($$I{fix_for} =~/$regex/o) {
              $$I{selected}{$$I{id}} = 1;
            }
            else {
              foreach my $SWB (@{$$I{SWB}}) {
                next if ($$SWB{problem});
                $$SWB{fix_for} ||= 'UNDEF';
                if ($$SWB{fix_for} =~/$regex/o) {
                  $$I{selected}{$$SWB{swb}} = 1;
                }
              }
            }               
            # only select the first fix-for match
            last if ($$I{selected});
          }
          $$I{problem} = 'No matching SW Branch Issue' unless ($$I{selected});
          $$I{problem} = 'Multiple matching SW Branch Issues' if ($$I{selected} && scalar keys %{$$I{selected}} > 1);
        }
        else {
          $$I{selected}{$$I{id}} = 1;
          foreach (@{$$I{SWB}}) {
            $$I{selected}{$$_{swb}} = 1 unless ($$_{problem});
          }
        }
      }     

      if ($Option{show}) {
        my $len_fix_for = 0;
        my $len_state = 0;
        foreach my $I (@Result) {
          $len_fix_for = List::Util::max($len_fix_for, length($$I{fix_for})) if ($$I{fix_for});
          $len_state = List::Util::max($len_state, length($$I{'state'})) if ($$I{'state'});
          foreach (@{$$I{SWB}}) {
            $len_fix_for = List::Util::max(length($$_{fix_for}), $len_fix_for) if ($$_{fix_for});
            $len_state = List::Util::max($len_state, length($$_{'state'})) if ($$_{'state'});
          }
        }

        # list related/matched Issues
        foreach my $I (@Result) {
          print ($$I{selected} && $$I{selected}{$$I{id}} ? print_marked() : ' ');
          print color('blue', 'bold') if (-t STDOUT && _USE_COLOR);
          print $$I{id}, '  ';
          print color('reset') if (-t STDOUT && _USE_COLOR);
          if (!$$I{fix_for} || $$I{fix_for} eq 'UNDEF') {
            $$I{fix_for} = ''; 
          }
          else {
            print $$I{fix_for};
          }
          print ' 'x(2 + $len_fix_for - length($$I{fix_for})), $$I{'state'},
                      ' 'x(2 + $len_state - length($$I{'state'})) if ($$I{'state'});
          print_problem($$I{problem});
          print "\n";
          foreach (@{$$I{SWB}}) {
            print ($$I{selected} && $$I{selected}{$$_{swb}} ? print_marked() . ' ' : '  ');
            print $$_{swb}, ' ';
            print $$_{fix_for} if ($$_{fix_for});
            print ' 'x(2 + $len_fix_for - length($$_{fix_for})), $$_{'state'},
                    ' 'x(2 + $len_state - length($$_{'state'})) if ($$_{'state'});
            print_problem($$_{problem});
            print "\n";
          }
        }
      }
      else {
        # create DMS Query
        my @Selected;
        foreach my $I (@Result) {
          if (@{$Option{'fix-for'}}) {
            push(@Selected, keys %{$$I{selected}}) if ($$I{selected});  
            print_error( header  => 'Failed: No matching DMS Issues found' ) unless (@Selected);
          } 
          else {
            push(@Selected, $$I{id});
            push(@Selected, map({$$_{swb}} @{$$I{SWB}}));
          }
        }

        if (@Selected) {
          my %Issue = map({$_ => 1} @Selected);
          @Selected = sort keys %Issue;
          
          # generate DMS query  
          my($problem, $result) = server_request('dms_query', $qryTemplate, @Selected);
            
          if ($problem) {
            print_error( header  => 'Failed: ',
                         message => $result );
          }
          elsif ($Option{qry} ne _UNDEF) {
            if (open(my $fh, '>', $Option{qry})) {
              binmode $fh;
              print $fh $result;
              close($fh);
            }
            else {
              print_error( header  => 'Failed: ',
                           message => 'Unable to write to file: ' . $Option{qry} );
            }
          }
          elsif (!-t STDOUT) {
            print $result;
          }
          else {
            print_error( header  => 'Failed: ',
                         message => 'No output file defined' );
          }
        }
        
        # notify user about problems  
        foreach my $I (@Result) {
          if ($$I{problem}) {
            print_error( header  => 'Problem[' . $$I{id} . '] ',
                         problem => $$I{problem} );
          }
          foreach (grep({$$_{problem}} @{$$I{SWB}})) {
            print_error( header  => 'Problem[' . $$_{swb} . '] ',
                         problem => $$I{problem} );
          }
        } 
      }
    }
  }
  else {
    print_error( header => 'No DMS Issues found' );
  }
}
elsif ($Option{show}) {
  if ($Option{'show-t'}) {
    my @Issue;
    foreach (keys %Parsed) {
      push(@Issue, (keys %{$Parsed{$_}{dms}}));
    }
  
    if (@Issue) {
      my %Issue = map({$_ => 1} @Issue);
      @Issue = sort keys %Issue;

      # get titles from DMS  
      my(@Result) = server_request('dms_info', @Issue);

      if (shift @Result) {
        # not critical, list without titles
        #print_error( header  => 'Failed: ',
        #             message => shift @Result );
      }
      else {
        %Issue = map({$$_{id} => $_} @Result);
        foreach my $project (keys %Parsed) {
          foreach (keys %{$Parsed{$project}{dms}}) {
            $Parsed{$project}{dms}{$_}{title} = $Issue{$_}{title};
          }
        }
      }
    }
  }
  
  foreach my $project (sort keys %Parsed) {
    if ($project ne _UNDEF) {
      if ($Option{'show-stat'} || scalar(keys %{$Parsed{$project}{dms}})) {
        print color('green', 'bold') if (-t STDOUT && _USE_COLOR);
        print $project, "\n";
        print color('reset') if (-t STDOUT && _USE_COLOR);
      }
    }
    elsif (!$Option{'show-stat'} && !$Option{'show-p'} && !scalar(keys %{$Parsed{$project}{dms}})) {
      print_error( header  => 'No DMS Issues found' );
    }
    if ($Option{'show-stat'} && $Parsed{$project}{commit}) {
      print ' ', scalar(keys %{$Parsed{$project}{dms}}), ' DMS Issues';
      print "\n ", $Parsed{$project}{commit}, ' commits, ', $Parsed{$project}{no_dms}, ' without DMS Issue';
      if ($Parsed{$project}{file}{count}) {
        print "\n ", $Parsed{$project}{file}{count}, ' files changed';
        print '(', $Parsed{$project}{file}{binary}, ' binary)' if ($Parsed{$project}{file}{binary});
        print ', ', $Parsed{$project}{file}{inserted}, ' insertions, ', $Parsed{$project}{file}{deleted}, ' deletions';
      }
      print "\n\n";
    }
    else {
      foreach (sort keys %{$Parsed{$project}{dms}}) {
        print color('blue', 'bold') if (-t STDOUT && _USE_COLOR);
        print ' ', ($Option{'main'} && $Parsed{$project}{dms}{$_}{main} ? $Parsed{$project}{dms}{$_}{main} : $_);
        print color('reset') if (-t STDOUT && _USE_COLOR);
        print ' ', $Parsed{$project}{dms}{$_}{title} if ($Option{'show-t'} && $Parsed{$project}{dms}{$_}{title});
        print "\n";
      }
    }
  }
}
else {
  my @Issue;
  foreach (keys %Parsed) {
    push(@Issue, (keys %{$Parsed{$_}{dms}}));
  }
  
  if (@Issue) {
    my %Issue = map({$_ => 1} @Issue);
    @Issue = sort keys %Issue;
    
    # generate DMS query  
    my($problem, $result) = server_request('dms_query', $qryTemplate, @Issue);

    if ($problem) {
      print_error( header  => 'Failed: ',
                   message => $result );
    }
    elsif ($Option{qry} ne _UNDEF) {
      if (open(my $fh, '>', $Option{qry})) {
        binmode $fh;
        print $fh $result;
        close($fh);
      }
      else {
        print_error( header  => 'Failed: ',
                     message => 'Unable to write to file: ' . $Option{qry} );
      }
    }
    elsif (!-t STDOUT) {
      print $result;
    }
    else {
      print_error( header  => 'Failed: ',
                   message => 'No output file defined' );
    }
  }
  else {
    print_error( header => 'No DMS Issues found' );
  }
}
exit;
__END__

